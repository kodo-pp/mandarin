# This file (grammar.py, NOT grammar.py.in) is auto-generated. Do not edit it as your changes will be overwritten.
# Edit Mandarin.lark.in instead

GRAMMAR = '// vim: set syntax=lark: \n// Mandarin compiler\n// Copyright (C) 2019  Alexander Korzun\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\n\ncode: toplevel_statement*\n\n?toplevel_statement: (function_definition | native_function_declaration | class_definition)? _NL\n\n\n// Class\n\nclass_definition: KW_CLASS IDENTIFIER _NL class_block_end\n\nclass_block_end: (class_statement | _NL)* KW_END\n\n?class_statement: (function_definition\n    | native_function_declaration\n    | var_declaration) _NL\n\n// Function\n\nnative_function_declaration: KW_DEF KW_NATIVE IDENTIFIER "(" typed_arglist ")"\n\nfunction_definition: KW_DEF IDENTIFIER "(" typed_arglist ")" _NL code_block_end\n\ntyped_arglist: (typed_arg ("," typed_arg)* ","?)?\n\ntyped_arg: typename? IDENTIFIER\n\ncode_block_end: code_statement* KW_END\n\n?code_statement: (expression\n    | var_declaration\n    | var_assignment\n    | if_statement\n    | for_statement\n    | while_statement\n    | return_statement) _NL\n\n\n// Variable\n\nvar_declaration: typename IDENTIFIER (strict_assignment_op expression)?\n\nvar_assignment: front_atomic_expression assignment_op expression\n\n// TODO: this is stub!\ntypename: IDENTIFIER\n\n\n// If statement\n\nif_statement: KW_IF expression _NL (code_block_elif expression _NL)* (code_block_else _NL)? code_block_end\n\ncode_block_elif: code_statement* KW_ELIF\n\ncode_block_else: code_statement* KW_ELSE\n\n\n// For statement\n\nfor_statement: KW_FOR IDENTIFIER KW_IN expression _NL code_block_end\n\n\n// While statement\n\nwhile_statement: KW_WHILE expression _NL code_block_end\n\n\n// Return statement\n\nreturn_statement: KW_RETURN expression\n\n// Expression\n\nexpression: g__binop_toplevel\n\nfront_atomic_expression: unop* atomic_expression\n\n?atomic_expression: literal | symbol | "(" expression ")" | function_call | property\n\n// CAN\'T THAT FUCKING LALR PARSE THIS SIMPLE THING?\n// OR IS LARK\'S IMPLEMENTATION ~~FUCKINGLY~~ TOTALLY FLAWED?\n// Fuck it, switching to Earley\nproperty: atomic_expression C_DOT IDENTIFIER\n\n//symbol: IDENTIFIER (C_DOT IDENTIFIER)*\nsymbol: IDENTIFIER\n\nfunction_call: atomic_expression call_operator\n\nliteral: NUMBER | STRING_SINGLE | STRING_DOUBLE\n\ncall_operator: "(" (expression ("," expression)*)? ")"\n\n\nKW_DEF:    /\\bdef\\b/\nKW_ELIF:   /\\belif\\b/\nKW_ELSE:   /\\belse\\b/\nKW_END:    /\\bend\\b/\nKW_FOR:    /\\bfor\\b/\nKW_IF:     /\\bif\\b/\nKW_IN:     /\\bin\\b/\nKW_NATIVE: /\\bnative\\b/\nKW_WHILE:  /\\bwhile\\b/\nKW_RETURN:  /\\breturn\\b/\nKW_CLASS:  /\\bclass\\b/\n\n// I\'m sorry about this piece of sh*t\n// See https://stackoverflow.com/a/2108017 for a piece of clarification of the hell happening here\nIDENTIFIER:    /\\b(?!(def|if|elif|else|end|for|while|in|while|native|return|class)\\b|[^a-zA-Z0-9_])[a-zA-Z_][a-zA-Z0-9_]*/\n\nNUMBER:        /[0-9]+/\nSTRING_DOUBLE: /"([^"\\\\]|\\\\.)*"/\nSTRING_SINGLE: /\'([^\'\\\\]|\\\\.)*\'/\n\nassignment_op: strict_assignment_op\n    | C_PLUS C_EQUAL\n    | C_MINUS C_EQUAL\n    | C_STAR C_EQUAL\n    | C_SLASH C_EQUAL\n    | C_SLASH C_SLASH C_EQUAL\n    | C_PERCENT C_EQUAL\n\nstrict_assignment_op: C_EQUAL\n\nbinop: C_STAR\n    | C_SLASH\n    | C_PERCENT\n    | C_SLASH C_SLASH\n    | C_PLUS\n    | C_MINUS\n    | C_DOT C_DOT C_DOT\n    | C_DOT C_DOT\n    | C_EQUAL C_EQUAL\n    | C_LESS C_EQUAL\n    | C_GREATER C_EQUAL\n    | C_BANG C_EQUAL\n    | C_LESS\n    | C_GREATER\n    | C_AMP C_AMP\n    | C_PIPE C_PIPE\n    | C_PLUS C_PLUS\n\nunop: C_MINUS\n    | C_PLUS\n    | C_BANG\n    | C_TILDE\n\nC_PLUS: "+"\nC_MINUS: "-"\nC_STAR: "*"\nC_SLASH: "/"\nC_EQUAL: "="\nC_LESS: "<"\nC_GREATER: ">"\nC_AMP: "&"\nC_PIPE: "|"\nC_DOT: "."\nC_PERCENT: "%"\nC_BANG: "!"\nC_TILDE: "~"\n\n?g__binop_1000: front_atomic_expression (C_STAR front_atomic_expression)* | front_atomic_expression (C_SLASH front_atomic_expression)* | front_atomic_expression (C_PERCENT front_atomic_expression)* | front_atomic_expression (C_SLASH C_SLASH front_atomic_expression)*\n?g__binop_500: g__binop_1000 (C_PLUS g__binop_1000)* | g__binop_1000 (C_MINUS g__binop_1000)*\n?g__binop_200: g__binop_500 (C_DOT C_DOT C_DOT g__binop_500)* | g__binop_500 (C_DOT C_DOT g__binop_500)*\n?g__binop_100: g__binop_200 (C_EQUAL C_EQUAL g__binop_200)* | g__binop_200 (C_LESS C_EQUAL g__binop_200)* | g__binop_200 (C_GREATER C_EQUAL g__binop_200)* | g__binop_200 (C_BANG C_EQUAL g__binop_200)* | g__binop_200 (C_LESS g__binop_200)* | g__binop_200 (C_GREATER g__binop_200)*\n?g__binop_30: g__binop_100 (C_AMP C_AMP g__binop_100)*\n?g__binop_20: g__binop_30 (C_PIPE C_PIPE g__binop_30)* | g__binop_30 (C_PLUS C_PLUS g__binop_30)*\n?g__binop_minus_1000: g__binop_20 (C_PLUS C_EQUAL g__binop_20)* | g__binop_20 (C_MINUS C_EQUAL g__binop_20)* | g__binop_20 (C_STAR C_EQUAL g__binop_20)* | g__binop_20 (C_SLASH C_EQUAL g__binop_20)* | g__binop_20 (C_SLASH C_SLASH C_EQUAL g__binop_20)* | g__binop_20 (C_PERCENT C_EQUAL g__binop_20)* | g__binop_20 (C_EQUAL g__binop_20)*\n?g__binop_toplevel: g__binop_minus_1000\n\n_NL: "\\r\\n" | "\\n"\n\nWS: /[ \\t]+/\n%ignore WS\n\nCOMMENT: /[#][^\\n]*/ _NL\n%ignore COMMENT\n'
# vim: set syntax=python:
