# This file (grammar.py, NOT grammar.py.in) is auto-generated. Do not edit it as your changes will be overwritten.
# Edit Mandarin.lark.in instead

GRAMMAR = '// vim: set syntax=lark: \n// Mandarin compiler\n// Copyright (C) 2019  Alexander Korzun\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\n\ncode: toplevel_statement*\n\n?toplevel_statement: (function_definition | native_function_declaration)? _NL\n\n\n// Function\n\nnative_function_declaration: KW_DEF KW_NATIVE IDENTIFIER "(" typed_arglist ")"\n\nfunction_definition: KW_DEF IDENTIFIER "(" typed_arglist ")" _NL code_block_end\n\ntyped_arglist: (typename? IDENTIFIER ("," typename? IDENTIFIER)* ","?)?\n\ncode_block_end: code_statement* KW_END\n\ncode_statement: (expression\n    | var_declaration\n    | var_assignment\n    | if_statement\n    | for_statement\n    | while_statement) _NL\n\n\n// Variable\n\nvar_declaration: typename IDENTIFIER (strict_assignment_op expression)?\n\nvar_assignment: atomic_expression assignment_op expression\n\ntypename: IDENTIFIER\n\n\n// If statement\n\nif_statement: KW_IF expression _NL (code_block_elif expression _NL)* (code_block_else _NL)? code_block_end\n\ncode_block_elif: code_statement* KW_ELIF\n\ncode_block_else: code_statement* KW_ELSE\n\n\n// For statement\n\nfor_statement: KW_FOR IDENTIFIER KW_IN expression _NL code_block_end\n\n\n// While statement\n\nwhile_statement: KW_WHILE expression _NL code_block_end\n\n\n// Expression\n\nexpression: front_atomic_expression (binop front_atomic_expression)*\n\n?front_atomic_expression: unop* atomic_expression\n\n?atomic_expression: literal | IDENTIFIER | "(" expression ")" | atomic_expression call_operator\n\n?literal: NUMBER | STRING_SINGLE | STRING_DOUBLE\n\ncall_operator: "(" (expression ("," expression)*)? ")"\n\n\nKW_DEF:    /\\bdef\\b/\nKW_ELIF:   /\\belif\\b/\nKW_ELSE:   /\\belse\\b/\nKW_END:    /\\bend\\b/\nKW_FOR:    /\\bfor\\b/\nKW_IF:     /\\bif\\b/\nKW_IN:     /\\bin\\b/\nKW_NATIVE: /\\bnative\\b/\nKW_WHILE:  /\\bwhile\\b/\n\n// I\'m sorry about this piece of sh*t\n// See https://stackoverflow.com/a/2108017 for a piece of clarification of the hell happening here\nIDENTIFIER:    /\\b(?!(def|if|elif|else|end|for|while|in|while|native)\\b|[^a-zA-Z0-9_])[a-zA-Z_][a-zA-Z0-9_]*/\n\nNUMBER:        /[0-9]+/\nSTRING_DOUBLE: /"([^"\\\\]|\\\\.)*"/\nSTRING_SINGLE: /\'([^\'\\\\]|\\\\.)*\'/\n\nassignment_op: strict_assignment_op\n    | C_PLUS C_EQUAL\n    | C_MINUS C_EQUAL\n    | C_STAR C_EQUAL\n    | C_SLASH C_EQUAL\n    | C_SLASH C_SLASH C_EQUAL\n    | C_PERCENT C_EQUAL\n\nstrict_assignment_op: C_EQUAL\n\nbinop: C_STAR\n    | C_SLASH\n    | C_PERCENT\n    | C_SLASH C_SLASH\n    | C_PLUS\n    | C_MINUS\n    | C_DOT C_DOT C_DOT\n    | C_DOT C_DOT\n    | C_EQUAL C_EQUAL\n    | C_LESS C_EQUAL\n    | C_GREATER C_EQUAL\n    | C_BANG C_EQUAL\n    | C_LESS\n    | C_GREATER\n    | C_AMP C_AMP\n    | C_PIPE C_PIPE\n    | C_PLUS C_PLUS\n\nunop: C_MINUS\n    | C_PLUS\n    | C_BANG\n    | C_TILDE\n\nC_PLUS: "+"\nC_MINUS: "-"\nC_STAR: "*"\nC_SLASH: "/"\nC_EQUAL: "="\nC_LESS: "<"\nC_GREATER: ">"\nC_AMP: "&"\nC_PIPE: "|"\nC_DOT: "."\nC_PERCENT: "%"\nC_BANG: "!"\nC_TILDE: "~"\n\n_NL: "\\r\\n" | "\\n"\n\nWS: /[ \\t]+/\n%ignore WS\n\nCOMMENT: /[#][^\\n]*/\n%ignore COMMENT\n'
# vim: set syntax=python:
