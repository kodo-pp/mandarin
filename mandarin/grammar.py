# This file is auto-generated. Do not edit it as your changes will be overwritten.
# Edit Mandarin.lark.in instead

GRAMMAR = '// vim: set syntax=lark: \n// Mandarin compiler\n// Copyright (C) 2019  Alexander Korzun\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\n//\n// ******************\n// ** PARSER RULES **\n// ******************\n//\n\ncode: toplevel_statement*\n\ntoplevel_statement: function_definition\n    | native_function_declaration\n    | NL\n\nnative_function_declaration: KW_DEF KW_NATIVE IDENTIFIER "(" typed_arglist? ")" NL\n\ntyped_arglist: NL* typename? NL* IDENTIFIER NL* ("," NL* typename? NL* IDENTIFIER NL*)* ","? NL*\n\ntypename: IDENTIFIER\n     | typename array_modifier\n\narray_modifier: "[" "]"\n\nfunction_definition: KW_DEF IDENTIFIER "(" typed_arglist? ")" NL code_block\n\ncode_block: (code_statement? NL+)* KW_END NL?\n\ncode_block_elif: (code_statement? NL+)* KW_ELIF expression NL\n\ncode_block_else: (code_statement? NL+)* KW_ELSE NL\n\ncode_statement: expression\n    | var_declaration\n    | var_assignment\n    | if_statement\n    | while_statement\n    | for_statement\n\nvar_declaration: typename IDENTIFIER ("=" expression)?\n\nvar_assignment: expression "=" expression\n\nif_statement: KW_IF expression NL (code_block_elif)* code_block_else? code_block\n\nwhile_statement: KW_WHILE expression NL code_block\n\nfor_statement: KW_FOR IDENTIFIER KW_IN expression NL code_block\n\nexpression: front_atomic_expression\n    | front_atomic_expression (BINOP front_atomic_expression)*\n\ncall_operator: "(" (NL* expression NL* ("," NL* expression NL*)* ","?)? ")"\n\natomic_expression: atomic_expression call_operator\n    | IDENTIFIER\n    | "(" expression ")"\n    | literal\n\nfront_atomic_expression: atomic_expression\n    | unary_operator front_atomic_expression\n\nliteral: num_integer\n    | num_float\n    | string\n\nnum_integer: SIGN? (INT_DEC | INT_BIN | INT_OCT | INT_HEX)\n\nnum_float: FLOAT\n\nstring: STRING_SINGLE\n    | STRING_DOUBLE\n\nunary_operator: "!"\n    | "+"\n    | "-"\n    | "~"\n\n//\n// *****************\n// ** LEXER RULES **\n// *****************\n//\n\nSIGN:               /[+-]/\nQUOTE_SINGLE:       "\'"\nQUOTE_DOUBLE:       "\\""\nINT_DEC:            /[0-9]+/\nINT_BIN:            /0b[01]+/\nINT_OCT:            /0o[0-7]+/\nINT_HEX:            /0x[0-9a-fA-F]+/\nFLOAT:              /[0-9]*[.][0-9]+(e[+-]?[0-9]+)?|[0-9]+[.][0-9]*(e[+-]?[0-9]+)?|[0-9]+e[+-]?[0-9]+/\n\nBINOP: "*"\n    | "/"\n    | "%"\n    | "//"\n    | "+"\n    | "-"\n    | "..."\n    | ".."\n    | "=="\n    | "<="\n    | ">="\n    | "!="\n    | "<"\n    | ">"\n    | "&&"\n    | "||"\n    | "++"\n    | "+="\n    | "-="\n    | "*="\n    | "/="\n    | "//="\n    | "%="\n    | "="\n\nKW_IF: "if"\nKW_WHILE: "while"\nKW_FOR: "for"\nKW_END: "end"\nKW_DEF: "def"\nKW_NATIVE: "native"\nKW_ELIF: "elif"\nKW_ELSE: "else"\nKW_IN: "in"\n\nIDENTIFIER:         /[a-zA-Z_][a-zA-Z0-9_]*/\n\nNL:                 "\\r\\n" | "\\n"\n\nSTRING_SINGLE:      /\'([^\'\\\\]|\\\\.)*\'/\nSTRING_DOUBLE:      /"([^"\\\\]|\\\\.)*"/\n\nCOMMENT:            /[#][^\\n]*/\n%ignore COMMENT\n\nWHITESPACE:         /[ \\t]+/\n%ignore WHITESPACE\n'
# vim: set syntax=python:
