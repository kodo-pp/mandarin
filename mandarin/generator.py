# Mandarin compiler
# Copyright (C) 2019  Alexander Korzun
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import abc
from typing import List

from . import analyzer as an
from . import targets


class Generator(object):
    def __init__(self, analyzer, options):
        self.analyzer = analyzer
        self.options = options

    def generate(self):
        buf = []
        class_defs     = self.analyzer.get_class_definitions()
        function_decls = self.analyzer.get_function_declarations()
        function_defs  = self.analyzer.get_function_definitions()
        buf += self.generate_prologue()
        buf += self.generate_class_declarations   (class_defs, function_decls, function_defs)
        buf += self.generate_function_declarations(class_defs, function_decls, function_defs)
        buf += self.generate_class_definitions    (class_defs, function_decls, function_defs)
        buf += self.generate_function_definitions (class_defs, function_decls, function_defs)
        buf += self.generate_epilogue()
        return ''.join(buf)

    @abc.abstractmethod
    def generate_prologue(self) -> List[str]:
        return []

    @abc.abstractmethod
    def generate_epilogue(self) -> List[str]:
        return []
    
    @abc.abstractmethod
    def generate_class_declarations(
        self,
        class_defs:     List[an.ClassDefinition],
        function_decls: List[an.FunctionDeclaration],
        function_defs:  List[an.FunctionDefiniton],
    ) -> List[str]:
        return []
    
    @abc.abstractmethod
    def generate_function_declarations(
        self,
        class_defs:     List[an.ClassDefinition],
        function_decls: List[an.FunctionDeclaration],
        function_defs:  List[an.FunctionDefiniton],
    ) -> List[str]:
        return []
    
    @abc.abstractmethod
    def generate_class_definitions(
        self,
        class_defs:     List[an.ClassDefinition],
        function_decls: List[an.FunctionDeclaration],
        function_defs:  List[an.FunctionDefiniton],
    ) -> List[str]:
        return []
    
    @abc.abstractmethod
    def generate_function_definitions(
        self,
        class_defs:     List[an.ClassDefinition],
        function_decls: List[an.FunctionDeclaration],
        function_defs:  List[an.FunctionDefiniton],
    ) -> List[str]:
        return []


class Indenter(object):
    def __init__(self, indent_string):
        self.indent_string = indent_string
        self.nest = 0

    def __enter__(self):
        self.nest += 1
        return self

    def __exit__(self, *args):
        self.nest -= 1

    def get_indentation(self):
        return self.indent_string * self.nest

    def indent(self, buf):
        code = ''.join(buf)
        lines = code.split('\n')
        indented_lines = [self.get_indentation() + line for line in lines]
        return '\n'.join(indented_lines)


class CxxGenerator(Generator):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.indenter = Indenter(' ' * 4)

    # STUB!
    def generate_prologue(self):
        return [
            '/* This file was auto-generated by Mandarin compiler */\n',
            '#include <csetjmp>\n',
            '#include <cstddef>\n',
            '#include <cstdint>\n',
            '#include <memory>\n',
            'namespace mandarin {namespace user {\n',
        ]

    def generate_epilogue(self):
        common_epilogue = [
            '}} /* namespace mandarin::user */\n',
        ]
        standalone_epilogue = [
            'int main(int argc, char** argv) {\n',
            '    mandarin::support::preinit();\n',
            '    mandarin::support::store_args(argc, argv);\n',
            '    auto scoped_init = mandarin::support::init();\n',
            '    mandarin::user::main();\n',
            '    return 0;\n',
            '}\n',
        ] if self.options['is_standalone'] else []
        return common_epilogue + standalone_epilogue

    def generate_class_declarations(self, class_defs, function_decls, function_defs):
        buf = []
        for cd in class_defs:
            buf += self.generate_class_declaration(cd)
        return buf

    def generate_class_declaration(self, cd):
        name = cd.name
        outer_buf = []
        outer_buf.append('class {} : public mandarin::support::Shared {{\n'.format(name))
        outer_buf.append('public:\n')
        buf = []
        for md in cd.method_decls:
            buf += self.generate_method_declaration(md, cd)
        outer_buf += buf
        outer_buf.append('};\n')
        return outer_buf

    def generate_method_declaration(self, md, cd):
        method_name = md.name
        has_typename, canonical_method_name = self.canonicalize_method_name(method_name, cd)
        buf = []
        if has_typename:
            return_type = md.return_type
            canonical_return_type = self.canonicalize_type(return_type)
            buf.append(f'    virtual {canonical_return_type} mndr_{canonical_method_name}(')
        else:
            buf.append(f'    virtual void mndr_{canonical_method_name}(')
        buf += self.generate_function_arguments(md)
        buf.append(f');\n');
        return buf

    def canonicalize_method_name(self, method_name, cd):
        raw_name = method_name.split('.')[-1]
        if raw_name == 'new':
            return False, 'new'
        elif raw_name == 'del':
            return False, 'del'
        else:
            return True, raw_name

    def canonicalize_type(self, typename):
        if typename.name == 'var':
            return 'mandarin::support::SharedDynamicObject'
        else:
            return 'mandarin::user::' + typename.name

    def generate_function_arguments(self, md):
        argument_strings = [
            f'{self.canonicalize_type(arg.type)} {arg.name}'
            for arg in md.arguments
        ]
        return [', '.join(argument_strings)]

    def generate_function_declarations(self, class_defs, function_decls, function_defs):
        return []

    def generate_class_definitions(self, class_defs, function_decls, function_defs):
        return []

    def generate_function_definitions(self, class_defs, function_decls, function_defs):
        return []


targets.targets.append(targets.Target(
    name            = 'cxx',
    GeneratorType   = CxxGenerator,
    description     = 'Built-in C++ target',
))
