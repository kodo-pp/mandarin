# Mandarin compiler
# Copyright (C) 2019  Alexander Korzun
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import abc
from typing import List

from . import analyzer as an
from . import targets


class Generator(object):
    def __init__(self, analyzer, options):
        self.analyzer = analyzer
        self.options = options

    def generate(self):
        buf = []
        class_defs     = self.analyzer.get_class_definitions()
        function_decls = self.analyzer.get_function_declarations()
        function_defs  = self.analyzer.get_function_definitions()
        buf += self.generate_prologue()
        buf += self.generate_class_declarations   (class_defs, function_decls, function_defs)
        buf += self.generate_function_declarations(class_defs, function_decls, function_defs)
        buf += self.generate_class_definitions    (class_defs, function_decls, function_defs)
        buf += self.generate_function_definitions (class_defs, function_decls, function_defs)
        buf += self.generate_epilogue()
        return ''.join(buf)

    @abc.abstractmethod
    def generate_prologue(self) -> List[str]:
        return []

    @abc.abstractmethod
    def generate_epilogue(self) -> List[str]:
        return []
    
    @abc.abstractmethod
    def generate_class_declarations(
        self,
        class_defs:     List[an.ClassDefinition],
        function_decls: List[an.FunctionDeclaration],
        function_defs:  List[an.FunctionDefiniton],
    ) -> List[str]:
        return []
    
    @abc.abstractmethod
    def generate_function_declarations(
        self,
        class_defs:     List[an.ClassDefinition],
        function_decls: List[an.FunctionDeclaration],
        function_defs:  List[an.FunctionDefiniton],
    ) -> List[str]:
        return []
    
    @abc.abstractmethod
    def generate_class_definitions(
        self,
        class_defs:     List[an.ClassDefinition],
        function_decls: List[an.FunctionDeclaration],
        function_defs:  List[an.FunctionDefiniton],
    ) -> List[str]:
        return []
    
    @abc.abstractmethod
    def generate_function_definitions(
        self,
        class_defs:     List[an.ClassDefinition],
        function_decls: List[an.FunctionDeclaration],
        function_defs:  List[an.FunctionDefiniton],
    ) -> List[str]:
        return []


class CxxGenerator(Generator):
    # STUB!
    def generate_prologue(self):
        return [
            '/* This file was auto-generated by Mandarin compiler */\n',
            '#include <csetjmp>\n',
            '#include <cstddef>\n',
            '#include <cstdint>\n',
            '#include <memory>\n',
            'namespace mandarin {namespace user {\n',
        ]

    def generate_epilogue(self):
        common_epilogue = [
            '}} /* namespace mandarin::user */\n',
        ]
        standalone_epilogue = [
            'int main(int argc, char** argv)\n',
            '{\n'
            '    mandarin::support::preinit()\n',
            '    mandarin::support::store_args(argc, argv);\n',
            '    auto scoped_init = mandarin::support::init();\n',
            '    mandarin::user::main();\n',
            '    return 0;\n'
            '}\n'
        ] if self.options['is_standalone'] else []
        return common_epilogue + standalone_epilogue

    def generate_class_declarations(self, class_defs, function_decls, function_defs):
        return []

    def generate_function_declarations(self, class_defs, function_decls, function_defs):
        return []

    def generate_class_definitions(self, class_defs, function_decls, function_defs):
        return []

    def generate_function_definitions(self, class_defs, function_decls, function_defs):
        return []


targets.targets.append(targets.Target(
    name            = 'cxx',
    GeneratorType   = CxxGenerator,
    description     = 'Built-in C++ target',
))
