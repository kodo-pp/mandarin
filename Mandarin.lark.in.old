// vim: set syntax=lark: 
// Mandarin compiler
// Copyright (C) 2019  Alexander Korzun
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

//
// ******************
// ** PARSER RULES **
// ******************
//

code: toplevel_statement*

toplevel_statement: function_definition
    | native_function_declaration
//    | NL

native_function_declaration: KW_DEF KW_NATIVE IDENTIFIER "(" typed_arglist? ")" NL

typed_arglist: NL* typename? NL* IDENTIFIER NL* ("," NL* typename? NL* IDENTIFIER NL*)* ","? NL*

typename: IDENTIFIER
     | typename array_modifier

array_modifier: "[" "]"

function_definition: KW_DEF IDENTIFIER "(" typed_arglist? ")" NL code_block

code_block: (code_statement? NL+)* KW_END NL?

code_block_elif: (code_statement? NL+)* KW_ELIF expression NL

code_block_else: (code_statement? NL+)* KW_ELSE NL

code_statement: expression
    | var_declaration
    | var_assignment
    | if_statement
    | while_statement
    | for_statement

var_declaration: typename IDENTIFIER ("=" expression)?

var_assignment: expression "=" expression

if_statement: KW_IF expression NL (code_block_elif)* code_block_else? code_block

while_statement: KW_WHILE expression NL code_block

for_statement: KW_FOR IDENTIFIER KW_IN expression NL code_block

expression: front_atomic_expression (BINOP front_atomic_expression)*

call_operator: "(" (NL* expression NL* ("," NL* expression NL*)* ","?)? ")"

atomic_expression: atomic_expression call_operator
    | IDENTIFIER
    | "(" expression ")"
    | literal

front_atomic_expression: atomic_expression
    | unary_operator+ front_atomic_expression

literal: num_integer
    | num_float
    | string

//num_integer: ("+" | "-")? (INT_DEC | INT_BIN | INT_OCT | INT_HEX)
num_integer: ("+" | "-")? (INT_DEC | INT_BIN | INT_HEX)

num_float: FLOAT

string: STRING_SINGLE
    | STRING_DOUBLE

unary_operator: "!"
    | "+"
    | "-"
    | "~"

//
// *****************
// ** LEXER RULES **
// *****************
//

QUOTE_SINGLE:       "'"
QUOTE_DOUBLE:       "\""
INT_DEC:            /[0-9]+/
INT_BIN:            /0b[01]+/
//INT_OCT:            /0o[0-7]+/
INT_HEX:            /0x[0-9a-fA-F]+/
FLOAT:              /[0-9]*[.][0-9]+(e[+-]?[0-9]+)?|[0-9]+[.][0-9]*(e[+-]?[0-9]+)?|[0-9]+e[+-]?[0-9]+/

// @@_operators_@@

// @@_keywords_@@

IDENTIFIER:         /[a-zA-Z_][a-zA-Z0-9_]*/

NL:                 "\r\n" | "\n"

STRING_SINGLE:      /'([^'\\]|\\.)*'/
STRING_DOUBLE:      /"([^"\\]|\\.)*"/

COMMENT:            /[#][^\n]*/
%ignore COMMENT

WHITESPACE:         /[ \t]+/
%ignore WHITESPACE
